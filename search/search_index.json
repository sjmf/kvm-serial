{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Serial KVM Controller (CH9329)","text":"<p>A Software KVM, using the CH9329 UART Serial to USB HID controller.</p> <p>Control your computers using an emulated keyboard and mouse!</p> <p>This app and python module allows you to control to a second device using a CH9329 module (or cable) and a video capture device. You can find these from vendors on eBay and AliExpress for a low price. However, there is very little software support available for these modules, and CH9329 protocol documentation is sparse.</p> <p>This software captures keyboard and mouse inputs from the local computer, sending these over a serial UART connection to the CH9329 USB HID module, which will output USB HID mouse and keyboard movements and scan codes to the remote computer.</p> <p>The <code>kvm_serial</code> package provides options for running the GUI, or as a script providing flexible options.</p> <p> </p> <p>Download the latest release for Windows, Mac or Linux.</p> <p>See Installation for information on installing serial drivers, if required.</p>"},{"location":"#gui-usage","title":"GUI Usage","text":"<p>Run the GUI using the executable for your platform, or with Python using <code>python -m kvm_serial</code>.</p> <p> The Serial KVM window running on OSX, controlling a Windows remote machine</p> <p>The module can be installed from PyPI (<code>pip install kvm-serial</code>), or locally from a cloned git repo (<code>pip install -e .</code>).</p> <p>The GUI app will do a lot of the work for you: it will enumerate video devices and serial ports, and give you a window to interact with the guest in. Application settings can be changed from the menus (File, Options, View), for example if the app doesn't select the correct devices by default.</p>"},{"location":"#kit-list","title":"Kit List","text":"<p>This module requires a little bit of hardware to get going. You will need:</p> <ul> <li>CH9329 module or cable</li> <li>Video capture card (e.g. HDMI)</li> </ul> <p>You can likely get everything you need for under \u00a330, which is incredible when compared to the price of a KVM crash cart adapter.</p>"},{"location":"#ch9329-modulecable-assembled-as-cables","title":"CH9329 module/cable assembled as cables","text":"<p>PLEASE NOTE: I am a hobbyist. I have no affiliation with any manufacturer developing or selling CH9329 hardware.</p> <p> A home-made serial KVM module: CH9329 module soldered to SILabs CP2102. CH340 works, too.</p> <p>So, I don't have a specific vendor to recommend, but if you put \"CH9329 cable usb\" into a search engine, you will find the right thing. Just make sure what you buy has \"CH9329\" in the name: a USB-A to USB-A cable won't do, and can damage your machine.</p> <p>The modules have a USB-A male connector on one end, and serial connector on the other. The cables have USB-A both ends, as they are already put together and should pretty much be plug-and-play: just make sure it's the right way around. I just soldered a CH9329 module to a UART transceiver chip myself, as above.</p>"},{"location":"#video-capture-card","title":"Video capture card","text":"<p>You also need a capture card that takes the display output from your remote machine, and presents it as a USB device to your local system. I found the \"UGREEN Video Capture Card HDMI to USB C Capture Device\" was a good balance of price versus value. The more you spend on a capture device, the more responsive your video feed will likely be (to a point). HDMI and VGA hardware is available.</p>"},{"location":"#installing-python-dependencies","title":"Installing Python Dependencies","text":"<p>Note: These instructions are not required if using the executables, but you may need to do some other setup. See Installation for information on installing serial drivers.</p> <p>Standard installation (running the application from <code>pip</code>):</p> <pre><code># OPTIONAL: Create and activate a Virtual environment\npython -m venv ./.venv\n./.venv/scripts/activate\n\n# Install the module from PyPI and run the GUI\npip install kvm-serial\npython -m kvm-serial\n</code></pre> <p>OR using <code>uv</code> package manager (a faster alternative to pip, if available): Note: <code>uv run</code> may not work on Windows. See #15.</p> <pre><code>uv run kvm-gui\n</code></pre> <p>Install from source (for development- includes PyInstaller for building executables, pytest for testing, etc.):</p> <pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"#script-usage","title":"Script Usage","text":"<p>A script called <code>control.py</code> is also provided for use directly from the terminal, so you can also control remotes from a headless environment! (e.g. Pi to Pi!)</p> <p>Packages must be installed first. Use your preferred python package manager. E.g.:</p> <p>Usage examples for the <code>control.py</code> script:</p> <pre><code># Run using module\npython -m kvm_serial.control\n\n# Run using `uv`\nuv run kvm-control\n\n# Run with mouse and video support; use a Mac OSX serial port:\npython -m kvm_serial.control -ex /dev/cu.usbserial-A6023LNH\n\n# Run the script using keyboard 'tty' mode (no mouse, no video)\npython control.py --mode tty /dev/tty.usbserial0\n\n# Run using `pyusb` keyboard mode (which requires root):\nsudo python control.py --mode usb /dev/tty.usbserial0\n\n# Increase logging using --verbose (or -v), and use COM1 serial port (Windows)\npython control.py --verbose COM1\n</code></pre> <p>Use <code>python control.py --help</code> to view all available options. Keyboard capture and transmission is the default functionality of control.py: a couple of extra parameters are used to enable mouse and video. For most purposes, the default capture mode will suffice.</p> <p>Mouse capture is provided using the parameter <code>--mouse</code> (<code>-e</code>). It uses pynput for capturing mouse input and transmits this over the serial link simultaneously to keyboard input. Appropriate system permissions (Privacy and Security) may be required to use mouse capture.</p> <p>Video capture is provided using the parameter <code>--video</code> (<code>-x</code>). It uses OpenCV for capturing frames from the camera device. Again, system permissions for webcam access may need to be granted.</p> <p>See Keyboard Modes for more information on the various other options to the script. Implementations are provided for all the main python input capture methods.</p>"},{"location":"#troubleshooting","title":"Troubleshooting","text":"<p>Permissions errors on Linux: if your system user does not have serial write permissions (resulting in a permission error), you can add your user to the <code>dialout</code> group: e.g. <code>sudo usermod -a -G dialout $USER</code>. You must fully log out of the system to apply the change.</p> <p>Difficulty installing requirements: If you get <code>command not found: pip</code> or similar when installing requirements, try: <code>python -m pip [...]</code> to run pip instead.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>With thanks to @beijixiaohu, the author of the ch9329Comm PyPi package and GitHub repo (in Chinese), some code of which is re-used under the MIT License.</p> <p>Thank you, once again, to everyone who has contributed to this project.</p>"},{"location":"#license","title":"License","text":"<p>(c) 2023-25 Samantha Finnigan and contributors (except where acknowledged) and released under MIT License.</p>"},{"location":"BUILD/","title":"Build Notes for KVM Serial","text":"<p>This document provides quick reference for building executables locally.</p>"},{"location":"BUILD/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>All dependencies from <code>requirements.txt</code> installed</li> <li>Development dependencies (includes PyInstaller):</li> <li>Using pip: <code>pip install -e \".[dev]\"</code></li> </ul>"},{"location":"BUILD/#building-locally","title":"Building Locally","text":""},{"location":"BUILD/#macos","title":"macOS","text":"<pre><code># Activate your virtual environment\nsource .venv/bin/activate  # or conda activate ch9329\n\n# Build the application\npyinstaller kvm-gui.spec\n\n# Sign with ad-hoc signature (required for proper permissions handling)\ncodesign --force --deep --sign - --entitlements assets/entitlements.plist \"dist/KVM Serial.app\"\n\n# Verify signature\ncodesign --verify --verbose \"dist/KVM Serial.app\"\n\n# Output location:\n# - dist/KVM Serial.app (macOS application bundle)\n</code></pre> <p>Note: Ad-hoc signing (using <code>-</code> as identity) is sufficient for local testing and allows the app to properly request camera permissions. For distribution, you'll need a proper Apple Developer certificate.</p>"},{"location":"BUILD/#windows","title":"Windows","text":"<pre><code># Activate your virtual environment\n.venv\\Scripts\\activate\n\n# Build the application\npyinstaller kvm-gui.spec\n\n# Output location:\n# - dist\\kvm-gui.exe (Windows executable)\n</code></pre>"},{"location":"BUILD/#linux","title":"Linux","text":"<pre><code># Activate your virtual environment\nsource .venv/bin/activate\n\n# Build the application\npyinstaller kvm-gui.spec\n\n# Output location:\n# - dist/kvm-gui (Linux executable)\n</code></pre>"},{"location":"BUILD/#testing-the-build","title":"Testing the Build","text":""},{"location":"BUILD/#macos_1","title":"macOS","text":"<pre><code># Run the built application\nopen \"dist/KVM Serial.app\"\n\n# Or from command line\n./dist/KVM\\ Serial.app/Contents/MacOS/kvm-gui\n</code></pre>"},{"location":"BUILD/#windows_1","title":"Windows","text":"<pre><code># Run the executable\ndist\\kvm-gui.exe\n</code></pre>"},{"location":"BUILD/#linux_1","title":"Linux","text":"<pre><code># Make executable (if needed)\nchmod +x dist/kvm-gui\n\n# Run it\n./dist/kvm-gui\n</code></pre>"},{"location":"BUILD/#build-configuration","title":"Build Configuration","text":"<p>The build is configured in <code>kvm-gui.spec</code>:</p> <ul> <li>Build mode:</li> <li>macOS: onedir mode (required for PyInstaller 7.0+)</li> <li>Windows/Linux: onefile mode for simpler distribution</li> <li>Icons: Platform-specific icons from <code>assets/</code> directory</li> <li>Hidden imports: Explicitly includes PyQt5, OpenCV, serial, pynput</li> <li>Excludes: Removes tkinter, matplotlib, scipy, pandas to reduce size</li> <li>Console: Disabled (GUI application)</li> <li>macOS:</li> <li>Creates .app bundle with Info.plist for camera/input permissions</li> <li>Includes entitlements file (<code>assets/entitlements.plist</code>) for:<ul> <li>Camera access</li> <li>PyInstaller runtime compatibility (JIT, unsigned memory, library loading)</li> </ul> </li> </ul>"},{"location":"BUILD/#troubleshooting","title":"Troubleshooting","text":""},{"location":"BUILD/#missing-modules-error","title":"Missing modules error","text":"<p>If you get \"ModuleNotFoundError\" when running the built executable:</p> <ol> <li>Add the missing module to <code>hiddenimports</code> in <code>kvm-gui.spec</code></li> <li>Rebuild with <code>pyinstaller kvm-gui.spec</code></li> </ol>"},{"location":"BUILD/#icon-not-showing","title":"Icon not showing","text":"<ul> <li>Verify icon files exist in <code>assets/</code> directory</li> <li>Check <code>icon</code> parameter in spec file points to correct file</li> </ul>"},{"location":"BUILD/#application-wont-start","title":"Application won't start","text":"<ul> <li>Run from terminal to see error messages</li> <li>Check that all dependencies are installed in your build environment</li> </ul>"},{"location":"BUILD/#macos-app-hangs-on-permission-prompt","title":"macOS: App hangs on permission prompt","text":"<p>If the macOS app hangs when requesting camera access:</p> <ol> <li>The app likely wasn't code signed with entitlements</li> <li>Rebuild and sign the app:</li> </ol> <pre><code>pyinstaller kvm-gui.spec\ncodesign --force --deep --sign - --entitlements assets/entitlements.plist \"dist/KVM Serial.app\"\n</code></pre> <ol> <li>If permissions were previously denied, reset them:</li> </ol> <pre><code>tccutil reset Camera dev.finnigan.kvm-serial\n</code></pre> <p>Why this happens: macOS requires apps to be code signed (even with ad-hoc signatures) to properly handle permission dialogs. Without signing, the permission callback system can fail, causing hangs.</p>"},{"location":"BUILD/#size-too-large","title":"Size too large","text":"<p>The one-file executable will be 150-300MB due to:</p> <ul> <li>PyQt5 (GUI framework)</li> <li>OpenCV (video capture)</li> <li>Python runtime</li> </ul> <p>This is normal for PyInstaller builds with these dependencies.</p>"},{"location":"BUILD/#cicd-builds","title":"CI/CD Builds","text":"<p>Automated builds are handled by GitHub Actions:</p> <ul> <li>Workflow: <code>.github/workflows/build-binaries.yml</code></li> <li>Triggers: On version tags (<code>v*</code>) or manual dispatch</li> <li>Platforms: macOS, Windows, and Linux</li> <li>Build artifacts:</li> <li>macOS: <code>KVM-Serial-{version}-macOS.zip</code> and <code>.dmg</code> (ad-hoc signed)</li> <li>Windows: <code>KVM-Serial-{version}-Windows.zip</code></li> <li>Linux: <code>KVM-Serial-{version}-x86_64.AppImage</code></li> <li>Artifacts: Automatically attached to GitHub releases</li> </ul>"},{"location":"BUILD/#code-signing-status","title":"Code Signing Status","text":"<ul> <li>macOS: Ad-hoc signed in CI (sufficient for testing, not for distribution)</li> <li>Windows: Not signed (users will see SmartScreen warnings)</li> <li>Linux: AppImage format doesn't require signing</li> </ul> <p>For public distribution, proper code signing certificates are needed:</p> <ul> <li>macOS: Apple Developer ID ($99/year)</li> <li>Windows: Code signing certificate (~$100-500/year)</li> </ul> <p>See <code>.github/workflows/README.md</code> for detailed workflow documentation.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to KVM Serial","text":"<p>Firstly, thank you for taking the time to contribute! I really appreciate it. \u2764\ufe0f</p> <p>This guide outlines how to contribute to the KVM Serial project, and helps ensure a smooth experience for everyone involved.</p> <p>If this project has been useful to you, please consider giving it a star. \u2b50\ufe0f</p>"},{"location":"CONTRIBUTING/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Code of Conduct</li> <li>I Have a Question</li> <li>Getting Started</li> <li>Development Setup</li> <li>How to Contribute</li> <li>Reporting Bugs</li> <li>Pull Requests</li> <li>Testing</li> <li>Documentation</li> </ul>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>This project is committed to providing a welcoming and inclusive environment for all contributors. In summary: be decent to others in this space, act in good faith and assume good faith on others' parts, and conduct onself in a way which would be acceptable in the workplace.</p> <p>All participants should:</p> <ul> <li>Be respectful and considerate in communications</li> <li>Show empathy towards other community members</li> <li>Accept constructive criticism gracefully</li> <li>Focus on what is best for the project</li> </ul> <p>Unacceptable behavior includes:</p> <ul> <li>Any conduct that would be inappropriate in a professional setting</li> <li>Harassment of any kind</li> <li>Discriminatory jokes and language</li> <li>Personal or political attacks</li> <li>Publishing others' private information</li> <li>Trolling or insulting comments</li> </ul> <p>Violations should be reported to the project maintainer(s), who will take appropriate action.</p>"},{"location":"CONTRIBUTING/#i-have-a-question","title":"I Have a Question","text":"<p>Before asking a question:</p> <ol> <li>Read the Home page and any available documentation</li> <li>Search existing Issues to see if your question has already been answered</li> <li>Search the internet for answers first: putting errors from the console into a search engine is a great place to start.</li> </ol> <p>If you still need clarification, please:</p> <ul> <li>Open a new issue</li> <li>Provide as much context as possible: issues saying \"it doesn't work\", without further detail, will be closed saying \"yes, it does\".</li> <li>Include relevant system information (OS, Python version, hardware details)</li> </ul>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"CONTRIBUTING/#forking-the-repository","title":"Forking the Repository","text":"<p>You will need to fork the repository if you want to contribute via Pull Request. If that's you, read on!</p> <ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally:    <pre><code>git clone https://github.com/your-username/kvm-serial.git\ncd kvm-serial\n</code></pre></li> <li>Add the canonical repository to pull upstream changes:    <pre><code>git remote add upstream https://github.com/sjmf/kvm-serial.git\n</code></pre></li> </ol>"},{"location":"CONTRIBUTING/#development-setup","title":"Development Setup","text":"<p>To develop the code, there's a few steps to get set up:</p> <ol> <li>Python Environment: Ensure you have Python 3.8+ installed</li> <li>Install Dependencies and Dev Dependencies:    <pre><code>pip install -e .\npip install '.[dev]'\n</code></pre></li> <li>Install Pre-commit Hooks:     <pre><code>pre-commit install\npre-commit run --all-files  # Run pre-commit on all files (optional)\n</code></pre></li> </ol> <p>Pre-commit hooks help to ensure that any code contributed follows the code style (<code>black</code>).</p>"},{"location":"CONTRIBUTING/#how-to-contribute","title":"How to Contribute","text":"<p>Contributions are fab! I really appreciate your being interested in this project. A contribution might be a bug report, a suggestion for a feature enhancement, addressing an oversight in the documentation or test suite, or just a well-structured question about how to use this project e.g. in a way we've not seen before.</p> <p>If you're considering giving back in the form of a contribution, here's the best way to do that:</p>"},{"location":"CONTRIBUTING/#reporting-bugs","title":"Reporting Bugs","text":""},{"location":"CONTRIBUTING/#before-submitting-a-bug-report","title":"Before Submitting a Bug Report","text":"<p>Please ensure you're using the latest version of the software and verify that the issue is actually a bug rather than a configuration problem or user error. Search through existing bug reports to see if someone else has already encountered the same problem.</p> <p>When preparing your bug report, collect comprehensive information about your system environment. This should include your Python version and operating system, details about your hardware setup (particularly the CH9329 device and any connected cameras), your serial port configuration, complete error messages with stack traces, and clear steps that reliably reproduce the issue.</p>"},{"location":"CONTRIBUTING/#how-to-submit-a-bug-report","title":"How to Submit a Bug Report","text":"<p>Open a new issue with a clear, descriptive title that summarizes the problem. Describe both what behavior you expected to see and what actually happened. The most valuable bug reports include step-by-step reproduction instructions that allow maintainers to recreate the issue on their own systems. Include all the system and configuration information you collected, as this context is often crucial for diagnosing the root cause.</p>"},{"location":"CONTRIBUTING/#pull-requests","title":"Pull Requests","text":""},{"location":"CONTRIBUTING/#before-creating-a-pull-request","title":"Before Creating a Pull Request","text":"<ol> <li>Create an Issue First: For significant changes, create an issue to discuss the approach</li> <li>Fork and Branch: Create a feature branch from <code>main</code></li> <li>Stay Updated: Regularly sync with upstream:    <pre><code>git fetch upstream\ngit rebase upstream/main\n</code></pre></li> </ol>"},{"location":"CONTRIBUTING/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<ol> <li>One Change Per PR: Submit separate PRs for different features/fixes</li> <li>Clear Description: Explain what your PR does and why</li> <li>Reference Issues: Link to related issues with \"Fixes #123\"</li> <li>Test Your Changes: Ensure all tests pass</li> <li>Follow Code Standards: Use pre-commit hooks and linting</li> </ol>"},{"location":"CONTRIBUTING/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<p>Examples:</p> <ul> <li><code>feat(video): add support for USB 3.0 cameras</code></li> <li><code>fix(serial): handle port disconnection gracefully</code></li> <li><code>docs(readme): update installation instructions</code></li> </ul>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":""},{"location":"CONTRIBUTING/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npython -m pytest\n\n# Run with coverage\npython -m pytest --cov=kvm_serial\n\n# Run specific test categories, e.g.:\npython -m pytest tests/kvm\npython -m pytest tests/backend\n</code></pre>"},{"location":"CONTRIBUTING/#writing-tests","title":"Writing Tests","text":"<p>Tests should be placed in the <code>tests/</code> directory. When writing new tests, focus on covering both successful operations and error conditions, ensuring that external dependencies like hardware devices are properly mocked to prevent actual device access during testing.</p> <p>Follow established patterns in the existing test suite, particularly around the use of context managers for patching and the helper methods provided by the base test class. The test structure emphasizes isolation and repeatability, so each test should be able to run independently without relying on state from other tests.</p> <p>Always check that tests pass in concert with other tests: tests can modify the global import state of the test environment, which can result in interference for example where a test accidentally makes an import which can then no longer be patched. I've gone to some lengths to check that tests don't interfere with each other (or skip them where they do), but it's far too easy to write a test where this can occur!</p>"},{"location":"CONTRIBUTING/#documentation","title":"Documentation","text":"<p>Documentation improvements are always welcome. Good documentation contributions focus on the user experience, and often come from people who have recently worked through setup or usage scenarios themselves.</p> <p>When updating documentation, prioritise clarity and accuracy over comprehensiveness. Include practical examples where they help illustrate concepts, and always test any instructions or code examples you add to ensure they work as described. If you're documenting new features, consider including both basic usage examples and more advanced scenarios.</p> <p>Documentation should be updated whenever functionality changes. This includes not just user-facing features, but also development processes, testing procedures, and troubleshooting information. The goal is to reduce friction for both users and future contributors.</p>"},{"location":"CONTRIBUTING/#legal-notice","title":"Legal Notice","text":"<p>By contributing to this project, you agree that:</p> <ul> <li>You have authored 100% of the contributed content</li> <li>You have the necessary rights to the content</li> <li>Your contribution may be provided under the project license</li> </ul>"},{"location":"CONTRIBUTING/#questions","title":"Questions?","text":"<p>If you have questions about contributing, feel free to:</p> <ul> <li>Open an issue</li> <li>Contact the maintainers</li> </ul> <p>Thank you for contributing to KVM Serial! \ud83c\udf89</p>"},{"location":"INSTALLATION/","title":"Installation Guide","text":"<p>This guide covers installing KVM Serial and its dependencies on Windows, macOS, and Linux.</p> <p>NOTE: If using the executable binaries, you do not need to also create the python environment, as this will be bundled in the application. However, steps regarding serial drivers still apply!</p>"},{"location":"INSTALLATION/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher for running from source</li> <li>USB to UART bridge connecting to the CH9329 serial device</li> <li>USB video capture device (for video functionality)</li> </ul>"},{"location":"INSTALLATION/#platform-specific-dependencies","title":"Platform Specific Dependencies","text":"<p>Note: On modern Windows and Mac, this application is signed without a paid developer certificate (between $99 and $300). You will therefore see the following prompts:</p> <p> </p> <p>In order to run the binary app on Mac OSX, you will need to right click -&gt; Open it. Otherwise, the above prompt will not show the \"Open\" option.</p> <p>On Windows, you will need to click \"More info\" on the SmartScreen dialog to \"Run anyway\".</p> <p>As always, do not run apps on your machine which you do not trust. The entire build chain and source code for this application is available in the GitHub repository for you to verify if desired.</p>"},{"location":"INSTALLATION/#windows","title":"Windows","text":"<p>Note: If you see \"No serial ports found\" and you've connected a USB serial device, ensure the drivers are properly installed (see below):</p>"},{"location":"INSTALLATION/#usb-to-uart-bridge-drivers","title":"USB to UART Bridge Drivers","text":"<p>Most CH9329 devices use a USB to UART bridge chip to communicate with your computer. You'll need to install the appropriate drivers based on which chip your device uses.</p> <p>Common USB to UART Bridge Chips:</p> <ol> <li>Silicon Labs CP210x (CP2102, CP2104, CP2105, etc.)</li> <li>Download: CP210x USB to UART Bridge VCP Drivers</li> <li> <p>Recommended Version: CP210x Windows Drivers v6.7.6 (Released 9/3/2020) or later</p> </li> <li> <p>FTDI (FT232, FT234X, FT4232H, etc.)</p> </li> <li> <p>Download: FTDI VCP Drivers</p> </li> <li> <p>Prolific PL2303</p> </li> <li>The Prolific product page for the PL2303 has gone. An alternative is available at: Plugable USB Serial Adapter Drivers</li> <li> <p>Alternately, a GitHub repo with Windows 11-compatible PL2303 drivers is available at theAmberLion/Prolific.</p> </li> <li> <p>WCH CH340/CH341</p> </li> <li>Download: WCH CH340 Drivers</li> <li>Note: Windows 10/11 often include these drivers automatically</li> </ol> <p>Installation Steps:</p> <ol> <li>Download the appropriate driver for your device's chip</li> <li>Extract and run the installer</li> <li>Connect your CH9329 device via USB</li> <li>Verify installation:</li> <li>Open Device Manager (Win + X \u2192 Device Manager)</li> <li>Look under \"Ports (COM &amp; LPT)\" for your device</li> <li>Note the COM port number (e.g., COM3, COM4)</li> </ol>"},{"location":"INSTALLATION/#windows-permissions","title":"Windows Permissions","text":"<p>Windows 10/11 Camera Access:</p> <p>On first launch, Windows may prompt for camera access permission. The application will:</p> <ol> <li>Display a Windows permission dialog asking for camera access</li> <li>Wait for your response (Allow/Deny)</li> <li>Continue normally after you respond</li> </ol> <p>If you need to change camera permissions later: Settings \u2192 Privacy &amp; security \u2192 Camera \u2192 Allow desktop apps to access your camera</p>"},{"location":"INSTALLATION/#macos","title":"macOS","text":"<p>Most USB-to-serial devices work out of the box on modern macOS systems without additional drivers.</p> <p>Verifying the device:</p> <p>Connect your device and verify it appears in <code>/dev/</code>:</p> <pre><code>ls /dev/cu.*\n</code></pre> <p>You should see a device like <code>/dev/cu.usbserial-xxxxx</code> or <code>/dev/cu.SLAB_USBtoUART</code></p> <p>If unavailable, you can list USB devices connected to the system using:</p> <pre><code>system_profiler SPUSBDataType\n</code></pre>"},{"location":"INSTALLATION/#macos-permissions","title":"macOS Permissions","text":"<p>macOS requires specific permissions for camera and input monitoring:</p> <ol> <li>Camera Access: The app will request camera permission on first launch</li> <li>Input Monitoring: System Preferences \u2192 Security &amp; Privacy \u2192 Privacy \u2192 Input Monitoring</li> </ol>"},{"location":"INSTALLATION/#linux","title":"Linux","text":""},{"location":"INSTALLATION/#usb-to-uart-kernel-modules","title":"USB to UART Kernel Modules","text":"<p>Most Linux distributions include kernel modules for common USB to UART bridge chips by default:</p> <ul> <li>CP210x: <code>cp210x</code></li> <li>FTDI: <code>ftdi_sio</code></li> <li>PL2303: <code>pl2303</code></li> <li>CH340/CH341: <code>ch341</code></li> </ul> <p>Verifying driver support:</p> <pre><code># Check if the driver is loaded (replace cp210x with your chip's module)\nlsmod | grep cp210x\n\n# Connect your device and check dmesg for detection\ndmesg | tail -20\n\n# List serial devices\nls /dev/ttyUSB* /dev/ttyACM* 2&gt;/dev/null\n</code></pre> <p>If the driver isn't loaded, it should automatically load when you connect the device. The device will typically appear as:</p> <ul> <li><code>/dev/ttyUSB0</code> (or ttyUSB1, ttyUSB2, etc.) for most USB-to-serial adapters</li> <li><code>/dev/ttyACM0</code> for some USB devices using the CDC ACM protocol</li> </ul> <p>Troubleshooting: If the device doesn't appear:</p> <ol> <li>Check kernel messages: <code>dmesg | grep -i usb</code></li> <li>Verify the USB connection: <code>lsusb</code> (look for your device)</li> <li>Ensure the kernel module is available: <code>modinfo cp210x</code> (or relevant module)</li> </ol>"},{"location":"INSTALLATION/#system-dependencies","title":"System Dependencies","text":"<p>Install required system libraries for PyQt5 and OpenCV:</p> <p>Ubuntu/Debian:</p> <pre><code>sudo apt-get update\nsudo apt-get install -y \\\n    libxcb-xinerama0 \\\n    libxcb-icccm4 \\\n    libxcb-image0 \\\n    libxcb-keysyms1 \\\n    libxcb-randr0 \\\n    libxcb-render-util0 \\\n    libxcb-xfixes0 \\\n    libxkbcommon-x11-0 \\\n    libgl1 \\\n    libegl1 \\\n    libxcb-cursor0\n</code></pre> <p>Fedora/RHEL:</p> <pre><code>sudo dnf install -y \\\n    libxcb \\\n    xcb-util-wm \\\n    xcb-util-image \\\n    xcb-util-keysyms \\\n    xcb-util-renderutil \\\n    libxkbcommon-x11 \\\n    mesa-libGL \\\n    mesa-libEGL\n</code></pre>"},{"location":"INSTALLATION/#user-permissions","title":"User Permissions","text":"<p>Serial Port Access:</p> <p>Linux requires users to be in the <code>dialout</code> group to access serial ports without root privileges. If you get permission denied errors when accessing serial ports, add the user to the group:</p> <pre><code># Add your user to the dialout group\nsudo usermod -a -G dialout $USER\n\n# Verify group membership\ngroups $USER\n\n# Log out and log back in for changes to take effect\n# OR reload groups in current session (may not work in all cases):\nnewgrp dialout\n</code></pre> <p>Important: You must log out and log back in (or restart) for the group changes to take effect system-wide. After logging back in, verify with:</p> <pre><code>groups  # Should show 'dialout' in the list\n</code></pre> <p>If you see \"Permission denied\" errors when trying to access <code>/dev/ttyUSB*</code> or <code>/dev/ttyACM*</code>, this is the most common cause.</p>"},{"location":"INSTALLATION/#common-issues","title":"Common Issues","text":""},{"location":"INSTALLATION/#no-serial-ports-found","title":"\"No serial ports found\"","text":"<ul> <li>Windows: Install serial drivers (see above). Check Device Manager for the device.</li> <li>macOS: Check <code>/dev/cu.*</code> for the device</li> <li>Linux: Check <code>/dev/ttyUSB*</code> or <code>/dev/ttyACM*</code></li> <li>Linux: Verify you're in the <code>dialout</code> group</li> <li>Try unplugging and reconnecting the device</li> </ul>"},{"location":"MODES/","title":"Keyboard capture mode comparison","text":"<p>Some capture methods require superuser privileges (<code>sudo</code>), for example <code>pyusb</code> provides the most accurate keyboard scancode capture, but needs to de-register the device driver for the input method in order to control it directly.</p> <p>For example usage, please see the accompanying blogpost: https://wp.finnigan.dev/?p=682</p> Mode Modifiers Paste Blocking Focus Exit Permissions <code>usb</code> \u2705 Yes \u274c No \u2705 Yes \u274c No Ctrl+ESC <code>sudo</code> / root <code>tty</code> \u274c No \u2705 Yes \u274c No \u2705 Yes Ctrl+C Standard user <code>pynput</code> \u2705 Yes \u274c No \u274c No \u274c No Ctrl+ESC Input monitoring (OSX) <code>curses</code> \u26a0\ufe0f Some \u2705 Yes \u274c No \u2705 Yes ESC Standard user <p>For <code>curses</code>, modifier support is incomplete but should be good enough to enable working in a terminal. Curses provides a good mix of functionality versus permissions and is therefore the default mode in keyboard-only mode. When running with mouse and video, <code>pynput</code> is selected automatically.</p> <p>A 'yes' in the remaining columns means:</p> <ul> <li>Modifiers: Keys like <code>Ctrl</code>, <code>Shift</code>, <code>Alt</code> and <code>Cmd</code>/<code>Win</code> will be captured. Combinations like Ctrl+C will be passed through.</li> <li>Paste:  Content can be pasted from host to guest. Paste text into the console and it will be transmitted char-wise to the HID device</li> <li>Blocking: Keyboard input will not function in other applications while the script is running</li> <li>Focus: The console must remain in focus for input to be recorded (and transmitted over the UART)</li> <li>Implication: You will need to select the best input method for your use case! </li> </ul>"},{"location":"TESTING/","title":"Testing Guide for kvm-serial","text":""},{"location":"TESTING/#overview","title":"Overview","text":"<p>This guide explains how <code>kvm-serial</code> achieves reliable automated testing for a PyQt5 GUI application that controls physical hardware. The challenge: how do you test an application that creates windows and talks to serial devices when you're running in a headless CI environment with no hardware attached?</p> <p>The answer involves extensive mocking: done carefully to avoid turning tests into meaningless stub checks. This document explains the testing approach and why these patterns matter for maintaining a robust test suite.</p>"},{"location":"TESTING/#the-testing-challenge","title":"The Testing Challenge","text":""},{"location":"TESTING/#what-makes-this-hard","title":"What Makes This Hard?","text":"<p>Testing kvm-serial isn't like testing a typical Python library. Several unique constraints exist:</p> <p>GUI Framework Limitations: PyQt5 expects a graphical environment. When you import the main application module, Qt immediately tries to initialise windows, menus, and event loops. In a headless CI environment (like GitHub Actions), this fails with errors about missing display servers. While a virtual X server could be installed to work around this, mocking the GUI framework is cleaner and faster.</p> <p>Hardware Dependencies: The application's core purpose is controlling serial devices and capturing video from cameras. Real hardware isn't available during testing, and even if it were, tests shouldn't depend on specific physical devices being connected.</p> <p>Import-Time Side Effects: Python executes code during module import. If an application creates a <code>QApplication</code> instance at the module level, it spawns a GUI before any test mocking can intercept it.</p> <p>State Management: Qt applications maintain global state. Without careful cleanup between tests, one test's mocks can pollute another test's environment, causing mysterious failures that only appear when running the full suite.</p>"},{"location":"TESTING/#the-core-strategy","title":"The Core Strategy","text":"<p>The solution: Mock everything external before it can be imported, test the logic without side effects, then aggressively clean up.</p> <p>This means mocking the Qt framework itself, mocking hardware APIs, and carefully controlling when and how modules get loaded into Python's import system. The result is tests that verify logic (event handling, state management, error recovery) without ever touching a GUI or serial port.</p>"},{"location":"TESTING/#architecture","title":"Architecture","text":""},{"location":"TESTING/#base-test-class-pattern","title":"Base Test Class Pattern","text":"<p><code>KVMTestBase</code> provides centralised mocking infrastructure that all test classes inherit:</p> <pre><code>class TestMyFeature(KVMTestBase):\n    def test_something(self):\n        app = self.create_kvm_app()  # Already mocked\n        # Test logic here\n</code></pre> <p>This inheritance pattern centralises all the mocking complexity in one place. Instead of every test file duplicating the same Qt mocking setup, they inherit from <code>KVMTestBase</code> and get it automatically. The base class handles starting patches before tests run and stopping them afterwards, preventing mock leakage between tests. It also provides utility methods for common operations like creating mock cameras or serial ports, making tests more readable and maintainable.</p>"},{"location":"TESTING/#mock-lifecycle","title":"Mock Lifecycle","text":"<ol> <li>setUp() - Create and start all patches before module import</li> <li>Test execution - Use mocked components</li> <li>tearDown() - Stop patches and clear modules from <code>sys.modules</code></li> </ol> <p>Critical: Module cleanup prevents test cross-contamination by forcing fresh imports.</p>"},{"location":"TESTING/#mocking-strategies","title":"Mocking Strategies","text":""},{"location":"TESTING/#1-pyqt5-gui-component-mocking","title":"1. PyQt5 GUI Component Mocking","text":"<p>Why: Prevent actual window creation and Qt application startup.</p> <p>Approach:</p> <pre><code>def _setup_qt_mocks(self):\n    patches = []\n\n    # Mock QApplication to prevent GUI startup\n    patches.append(patch(\"PyQt5.QtWidgets.QApplication\"))\n\n    # Mock QMainWindow.__init__ to skip window creation\n    def mock_qmainwindow_init(self):\n        pass\n    patches.append(patch(\"PyQt5.QtWidgets.QMainWindow.__init__\", \n                        mock_qmainwindow_init))\n\n    # Mock all widget classes\n    for widget in [\"QLabel\", \"QMenu\", \"QMessageBox\", ...]:\n        patches.append(patch(f\"PyQt5.QtWidgets.{widget}\"))\n\n    return patches\n</code></pre> <p>Key insight: Mock both classes and methods. Class mocks prevent instantiation issues; method mocks handle calls on instances.</p>"},{"location":"TESTING/#2-hardware-abstraction-mocking","title":"2. Hardware Abstraction Mocking","text":"<p>Why: Tests shouldn't require physical devices.</p> <p>Approach: <pre><code>def _setup_hardware_mocks(self):\n    return [\n        patch(\"kvm_serial.backend.video.CaptureDevice\"),\n        patch(\"kvm_serial.utils.communication.list_serial_ports\"),\n        patch(\"kvm_serial.kvm.Serial\"),\n    ]\n</code></pre></p> <p>Pattern: Mock at the interface boundary where the application interacts with hardware libraries.</p>"},{"location":"TESTING/#3-module-level-import-mocking","title":"3. Module-Level Import Mocking","text":"<p>Critical timing issue: Mocks must exist before importing the tested module.</p> <pre><code>def setUp(self):\n    # Start patches FIRST\n    self.qt_patches = self._setup_qt_mocks()\n    for patcher in self.qt_patches:\n        patcher.start()\n\n    # Import AFTER mocking\n    from kvm_serial import kvm\n    self.kvm_module = kvm\n</code></pre> <p>Why this matters: Python imports execute module code. If GUI initialisation happens during import, you've already created windows before mocking can prevent it.</p>"},{"location":"TESTING/#4-context-manager-pattern-for-targeted-mocking","title":"4. Context Manager Pattern for Targeted Mocking","text":"<p>For test-specific mocking beyond the base infrastructure:</p> <pre><code>def test_serial_port_selection(self):\n    app = self.create_kvm_app()\n\n    with self.patch_kvm_method(app, \"_KVMQtGui__init_serial\") as mock:\n        app._on_serial_port_selected(\"/dev/ttyUSB0\")\n        mock.assert_called_once()\n</code></pre> <p>Python's context managers (<code>with</code> statements) provide automatic cleanup: when the block exits, the patch is automatically removed, even if an exception occurs. This makes it immediately clear which parts of the test are using mocked behaviour and which aren't, improving test readability.</p>"},{"location":"TESTING/#5-test-mixins-for-domain-specific-utilities","title":"5. Test Mixins for Domain-Specific Utilities","text":"<p>Mixins provide specialised testing utilities without cluttering the base class:</p> <pre><code>class TestKVMDeviceManagement(\n    KVMTestBase,\n    KVMTestMixins.SerialTestMixin,\n    KVMTestMixins.VideoTestMixin\n):\n    def test_populate_serial_ports(self):\n        test_ports = self.create_mock_serial_ports()  # From mixin\n        # Test logic\n</code></pre> <p>Each mixin adds domain-specific helper methods without forcing every test to inherit functionality it doesn't need. <code>SerialTestMixin</code> provides methods for creating mock serial ports, <code>VideoTestMixin</code> handles mock cameras, and <code>SettingsTestMixin</code> helps with configuration file testing. Tests can mix and match these based on what they're testing.</p>"},{"location":"TESTING/#common-patterns","title":"Common Patterns","text":""},{"location":"TESTING/#creating-mock-devices","title":"Creating Mock Devices","text":"<p>Serial ports:</p> <pre><code>test_ports = self.create_mock_serial_ports()\n# Returns: [\"/dev/ttyUSB0\", \"/dev/ttyUSB1\", \"/dev/ttyACM0\"]\n</code></pre> <p>Cameras:</p> <pre><code>cameras = self.create_mock_cameras(count=2)\n# Each has: .index, .width, .height, __str__()\n</code></pre>"},{"location":"TESTING/#error-handling-tests","title":"Error Handling Tests","text":"<p>Pattern for exception testing:</p> <pre><code>with (\n    patch(\"module.function\", side_effect=Exception(\"Failed\")),\n    patch(\"PyQt5.QtWidgets.QMessageBox.critical\") as mock_msg\n):\n    app.method_under_test()\n    self.assert_error_handling(mock_msg)\n</code></pre> <p>This pattern ensures robust error handling: the test verifies that exceptions don't crash the application and that users receive appropriate error messages. Many tests only check one or the other, missing subtle bugs where errors are caught but users aren't informed.</p>"},{"location":"TESTING/#testing-invalid-input","title":"Testing Invalid Input","text":"<p>Use <code>subTest</code> for multiple invalid cases:</p> <pre><code>invalid_ports = [\"None found\", \"Error\", None, \"\"]\nfor invalid_port in invalid_ports:\n    with self.subTest(port=invalid_port):\n        app.serial_port_var = invalid_port\n        app._KVMQtGui__init_serial()\n        self.assertIsNone(app.serial_port)\n</code></pre> <p>Without <code>subTest</code>, the first failure would stop the test, leaving other cases untested. Using <code>subTest</code> means all invalid inputs get tested even if some fail, and test output clearly identifies which specific input caused problems, making debugging much faster.</p>"},{"location":"TESTING/#best-practices","title":"Best Practices","text":""},{"location":"TESTING/#1-mock-at-boundaries-not-implementation","title":"1. Mock at Boundaries, Not Implementation","text":"<p>\u274c Don't mock:</p> <pre><code>patch(\"kvm_serial.kvm.KVMQtGui._internal_helper\")\n</code></pre> <p>\u2705 Do mock:</p> <pre><code>patch(\"serial.Serial\")\npatch(\"cv2.VideoCapture\")\n</code></pre> <p>Mock external dependencies, not internal code (except when deliberately isolating units).</p>"},{"location":"TESTING/#2-verify-behaviour-not-implementation","title":"2. Verify Behaviour, Not Implementation","text":"<p>\u274c Don't test:</p> <pre><code>mock_method.assert_called()\n</code></pre> <p>\u2705 Do test:</p> <pre><code>self.assertEqual(app.serial_port_var, expected_port)\nself.assertTrue(app.keyboard_op is not None)\n</code></pre> <p>Focus on observable outcomes rather than internal method calls.</p>"},{"location":"TESTING/#3-use-type-appropriate-assertions","title":"3. Use Type-Appropriate Assertions","text":"<pre><code># For lists\nself.assertEqual(len(app.baud_rates), 8)\nself.assertIn(9600, app.baud_rates)\n\n# For booleans\nself.assertFalse(app.keyboard_var)\nself.assertTrue(hasattr(app, \"video_worker\"))\n\n# For None\nself.assertIsNone(app.serial_port)\n</code></pre>"},{"location":"TESTING/#4-test-initialisation-state","title":"4. Test Initialisation State","text":"<p>After creating the app, verify default values:</p> <pre><code>def test_default_values(self):\n    app = self.create_kvm_app()\n\n    self.assertEqual(app.target_fps, 30)\n    self.assertFalse(app.keyboard_var)\n    self.assertEqual(app.video_var, -1)\n</code></pre> <p>Catches regression in default configuration.</p>"},{"location":"TESTING/#5-module-cleanup","title":"5. Module Cleanup","text":"<p>Always remove tested modules in tearDown:</p> <pre><code>def tearDown(self):\n    patch.stopall()\n\n    for module in [\"kvm_serial.kvm\", \"kvm_serial.backend.video\"]:\n        if module in sys.modules:\n            del sys.modules[module]\n</code></pre> <p>Prevents test interdependencies and ensures fresh imports.</p>"},{"location":"TESTING/#6-early-module-mocking-with-pytest_configure","title":"6. Early Module Mocking with pytest_configure","text":"<p>The Problem: Some production modules use module-level imports like <code>from serial.tools import list_ports</code>. This import executes when Python loads the module, before any test setup can mock it. The real <code>serial</code> module gets loaded and cached in <code>sys.modules</code>, making any subsequent mocking attempts ineffective since Python won't re-import an already cached module.</p> <p>Why Not Modify Production Code?: We could add <code>try/except</code> blocks or lazy imports to production code, but that would be polluting the codebase to accommodate tests: exactly backwards. Tests should adapt to production code, not the other way around.</p> <p>The Solution: Use pytest's <code>pytest_configure</code> hook to inject mocks into Python's module system before any test collection begins. This runs even before pytest discovers test files, ensuring mocks are in place for module-level imports.</p> <pre><code># tests/utils/conftest.py\nimport sys\nfrom unittest.mock import MagicMock\nfrom tests._utilities import MockSerial\n\ndef pytest_configure(config):\n    \"\"\"Called before test collection begins\"\"\"\n    # Create mock hierarchy - must be connected so imports work\n    mock_list_ports = MagicMock()\n    mock_list_ports.comports = MagicMock(return_value=[])\n\n    mock_tools = MagicMock()\n    mock_tools.list_ports = mock_list_ports\n\n    mock_serial_mod = MagicMock()\n    mock_serial_mod.Serial = MockSerial\n    mock_serial_mod.SerialException = Exception\n    mock_serial_mod.tools = mock_tools\n\n    # Inject into sys.modules - hierarchy must match\n    sys.modules['serial'] = mock_serial_mod\n    sys.modules['serial.tools'] = mock_tools\n    sys.modules['serial.tools.list_ports'] = mock_list_ports\n</code></pre> <p>Why the Hierarchy Matters: Notice how <code>mock_serial_mod.tools</code> points to the same object as <code>sys.modules['serial.tools']</code>. This is crucial. When Python imports <code>serial.tools.list_ports</code>, it follows the hierarchy: first it finds <code>serial</code> in <code>sys.modules</code>, then accesses its <code>.tools</code> attribute, then accesses <code>.list_ports</code>. If these aren't the same object references, Python creates multiple mock instances. Tests will fail with mysterious assertion errors like <code>Expected 'method' to be called once. Called 0 times.</code> because the code under test called a different mock instance than the one being asserted against.</p> <p>The sys.modules Pollution Tradeoff: This approach modifies global state (<code>sys.modules</code>) that persists across all tests in a pytest session. That sounds dangerous: and it is. The tradeoff is that <code>pytest tests/</code> will fail in ways that are unclear to the developer, so we have to work around this. The CI workflow runs test groups in separate pytest invocations (backend, utils, kvm, control), giving each a fresh Python process with clean <code>sys.modules</code>.</p> <p>This means:</p> <ul> <li>Each test group can safely mock <code>sys.modules</code> without affecting others</li> <li>Running <code>pytest tests/</code> locally might fail due to mock conflicts, but CI will pass</li> <li>Always test using the same commands as CI: <code>pytest tests/backend/</code>, <code>pytest tests/utils/</code>, etc.</li> </ul> <p>Where to Use This: Only test directories that import production code with module-level serial imports need this pattern. Currently: <code>tests/utils/</code> and <code>tests/backend/</code>. The KVM tests don't need it because they mock at a higher level.</p>"},{"location":"TESTING/#test-organisation","title":"Test Organisation","text":""},{"location":"TESTING/#categories","title":"Categories","text":"<p>Tests are organised by feature area (see Test_Categories document):</p> <ol> <li>Initialization &amp; Configuration (<code>test_kvm_init.py</code>)</li> <li>Window setup</li> <li>Menu creation</li> <li>Settings loading/saving</li> <li> <p>Device discovery</p> </li> <li> <p>Device Management (<code>test_kvm_device_mgmt.py</code>)</p> </li> <li>Serial port selection</li> <li>Camera enumeration</li> <li>Baud rate configuration</li> <li> <p>Connection error handling</p> </li> <li> <p>Settings Persistence (covered in init tests)</p> </li> <li>INI file operations</li> <li>Default value handling</li> <li> <p>Invalid settings recovery</p> </li> <li> <p>Event Handling (future expansion)</p> </li> <li>Mouse coordinate translation</li> <li>Keyboard event processing</li> <li> <p>Focus management</p> </li> <li> <p>Video Processing (future expansion)</p> </li> <li>Frame capture logic</li> <li>Frame rate management</li> <li>Error handling</li> </ol>"},{"location":"TESTING/#file-naming","title":"File Naming","text":"<ul> <li><code>test_kvm_base.py</code> - Base classes and utilities</li> <li><code>test_kvm_*.py</code> - Feature-specific test suites</li> <li>Mirrors source structure for easy navigation</li> </ul>"},{"location":"TESTING/#directory-structure-and-test-isolation","title":"Directory Structure and Test Isolation","text":"<p>The test suite is organised to match how CI runs tests: this organisation isn't arbitrary, it's essential for the mocking strategy to work:</p> <pre><code>tests/\n\u251c\u2500\u2500 backend/           # Backend implementation tests\n\u2502   \u251c\u2500\u2500 conftest.py   # Serial module mocking for backend\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 kvm/              # GUI application tests\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 utils/            # Utility module tests\n\u2502   \u251c\u2500\u2500 conftest.py   # Serial module mocking for utils\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 test_control.py   # Control module tests\n</code></pre>"},{"location":"TESTING/#why-separate-pytest-invocations-matter","title":"Why Separate pytest Invocations Matter","text":"<p>The GitHub Actions workflow (<code>.github/workflows/test.yml</code>) deliberately runs each test group as a separate command:</p> <pre><code>pytest tests/backend/  # Separate process\npytest tests/utils/    # Separate process\npytest tests/kvm/      # Separate process\npytest tests/test_control.py  # Separate process\n</code></pre> <p>This isn't just for organisation: it's fundamental to how the mocking works. Each pytest invocation spawns a fresh Python interpreter with a clean <code>sys.modules</code> dictionary. This means:</p> <p>The Good: Test groups with different mocking needs (like <code>tests/utils/</code> and <code>tests/kvm/</code>) can each pollute <code>sys.modules</code> however they want without interfering with each other. The <code>pytest_configure</code> hook in <code>tests/utils/conftest.py</code> mocks the serial module for utils tests, and by the time <code>tests/kvm/</code> runs, that's in a completely different process with no memory of those mocks.</p> <p>The Gotcha: Running <code>pytest tests/</code> locally runs all test groups in one process. The <code>pytest_configure</code> hooks from multiple <code>conftest.py</code> files all run in the same <code>sys.modules</code>, causing conflicts. Tests might fail locally but pass in CI.</p> <p>Best Practice: Always test using the CI commands. If you're working on backend code, run <code>pytest tests/backend/</code>. If you need to verify everything works, run each group separately just like CI does.</p> <p>This is an intentional tradeoff: running the entire suite locally is awkward in exchange for being able to mock aggressively without complex isolation machinery.</p>"},{"location":"TESTING/#running-tests","title":"Running Tests","text":""},{"location":"TESTING/#basic-execution","title":"Basic Execution","text":"<pre><code># Run all tests\npytest\n\n# Run specific test file\npytest tests/test_kvm_init.py\n\n# Run specific test\npytest tests/test_kvm_init.py::TestKVMInitialization::test_window_initialization\n\n# Verbose output\npytest -v\n\n# With coverage\npytest --cov=kvm_serial\n</code></pre>"},{"location":"TESTING/#configuration","title":"Configuration","text":"<p>Tests configured in <code>pyproject.toml</code>:</p> <pre><code>[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\"]\naddopts = [\"-v\", \"--tb=short\", \"--cov=kvm_serial\"]\ntimeout = 5\n</code></pre> <p>Timeout protection: Safeguard against event loop issues or runaway threads during testing.</p>"},{"location":"TESTING/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"TESTING/#issue-tests-fail-with-display-errors","title":"Issue: Tests Fail with Display Errors","text":"<p>Cause: GUI initialisation not properly mocked, causing Qt to attempt creating windows.</p> <p>Solution: Ensure <code>_setup_qt_mocks</code> includes all used Qt components. Add missing widgets to mock lists. Tests may also timeout if event loops are created: check that <code>QApplication</code> and <code>QTimer</code> are mocked.</p>"},{"location":"TESTING/#issue-import-errors-in-tests","title":"Issue: Import Errors in Tests","text":"<p>Cause: Module imported before mocks established.</p> <p>Solution: Move import inside <code>setUp</code> after starting patches.</p>"},{"location":"TESTING/#issue-tests-pass-individually-but-fail-in-suite","title":"Issue: Tests Pass Individually but Fail in Suite","text":"<p>Cause: Missing module cleanup in <code>tearDown</code>.</p> <p>Solution: Verify all tested modules are removed from <code>sys.modules</code>.</p>"},{"location":"TESTING/#issue-attributeerror-mock-object-has-no-attribute-x","title":"Issue: \"AttributeError: Mock object has no attribute X\"","text":"<p>Cause: Mock needs return value or side effect configuration.</p> <p>Solution: <pre><code>mock_obj = MagicMock()\nmock_obj.method.return_value = expected_value\n</code></pre></p>"},{"location":"TESTING/#issue-serial-exception-not-caught","title":"Issue: Serial Exception Not Caught","text":"<p>Cause: Exception mock not configured properly.</p> <p>Solution: <pre><code>with patch(\"serial.Serial\", side_effect=SerialException(\"Port not available\")):\n    # Test code\n</code></pre></p>"},{"location":"TESTING/#continuous-integration","title":"Continuous Integration","text":"<p>Tests run automatically via GitHub Actions (see <code>.github/workflows/test.yml</code>). Key considerations:</p> <ul> <li>Headless environment (no X server)</li> <li>All GUI mocking must be comprehensive  </li> <li>Timeout protection essential</li> <li>Coverage reporting to track test completeness</li> </ul>"},{"location":"TESTING/#future-enhancements","title":"Future Enhancements","text":"<p>Potential test suite improvements:</p> <ol> <li>Event Handling Tests</li> <li>Mouse coordinate translation logic</li> <li>Keyboard event processing</li> <li> <p>Serial communication triggers</p> </li> <li> <p>Video Processing Tests </p> </li> <li>Frame capture request logic</li> <li>Frame rate management</li> <li> <p>Canvas size updates</p> </li> <li> <p>Integration Tests</p> </li> <li>End-to-end workflows</li> <li>Settings persistence across restarts</li> <li> <p>Device reconnection scenarios</p> </li> <li> <p>Performance Tests</p> </li> <li>Frame rate under load</li> <li>Memory usage patterns</li> <li>Serial communication latency</li> </ol>"},{"location":"TESTING/#summary","title":"Summary","text":"<p>The kvm-serial test suite demonstrates effective PyQt5 application testing through:</p> <ul> <li>Comprehensive mocking preventing unwanted side effects</li> <li>Inheritance-based organisation providing reusable infrastructure</li> <li>Clear patterns for common testing scenarios</li> <li>Proper isolation ensuring test independence</li> </ul> <p>These strategies enable confident refactoring and feature development while maintaining reliable test coverage.</p>"},{"location":"workflows/","title":"GitHub Actions Workflows","text":"<p>This directory contains CI/CD workflows for the KVM Serial project.</p>"},{"location":"workflows/#workflows","title":"Workflows","text":""},{"location":"workflows/#testyml-continuous-testing","title":"<code>test.yml</code> - Continuous Testing","text":"<p>Triggers: Push to any branch, pull requests Purpose: Run unit tests and code coverage</p> <ul> <li>Runs pytest test suite</li> <li>Generates coverage reports</li> <li>Uploads coverage to Codecov</li> </ul>"},{"location":"workflows/#lintyml-code-quality","title":"<code>lint.yml</code> - Code Quality","text":"<p>Triggers: Push to any branch, pull requests Purpose: Enforce code style</p> <ul> <li>Runs Black code formatter check</li> <li>Ensures consistent code formatting</li> </ul>"},{"location":"workflows/#releaseyml-pypi-release","title":"<code>release.yml</code> - PyPI Release","text":"<p>Triggers: Push to tags matching <code>v*</code> (e.g., v1.5.2) Purpose: Publish Python package to PyPI</p> <p>Jobs: 1. test - Run full test suite 2. build-and-publish - Build and publish to PyPI using OIDC 3. create-release - Create GitHub release with auto-generated notes</p>"},{"location":"workflows/#build-binariesyml-executable-builds","title":"<code>build-binaries.yml</code> - Executable Builds","text":"<p>Triggers: Push to tags matching <code>v*</code>, manual dispatch Purpose: Build platform-specific executables and attach to release</p> <p>Jobs: 1. build-macos - Build macOS application    - Runs on: <code>macos-latest</code>    - Output: <code>KVM Serial.app</code> (onedir .app bundle)    - Ad-hoc code signing with entitlements (camera access, PyInstaller compatibility)    - Creates: ZIP and DMG for distribution    - Size: ~331 MB</p> <ol> <li>build-windows - Build Windows executable</li> <li>Runs on: <code>windows-latest</code></li> <li>Output: <code>kvm-gui.exe</code> (onefile executable)</li> <li>Creates: ZIP for distribution</li> <li> <p>Size: ~150-200 MB (estimated)</p> </li> <li> <p>build-linux - Build Linux AppImage</p> </li> <li>Runs on: <code>ubuntu-latest</code></li> <li>Output: <code>KVM-Serial-x86_64.AppImage</code> (portable executable)</li> <li>Creates: Standalone AppImage for distribution</li> <li>Installs PyQt5 system dependencies</li> <li> <p>Size: ~200-250 MB (estimated)</p> </li> <li> <p>upload-release-assets - Upload binaries to release</p> </li> <li>Waits for all three builds to complete</li> <li>Downloads all build artifacts</li> <li>Uploads to the GitHub release created by <code>release.yml</code></li> </ol>"},{"location":"workflows/#release-process","title":"Release Process","text":"<p>When you push a version tag (e.g., <code>v1.5.2</code>), the following happens automatically:</p> <pre><code>Tag pushed: v1.5.2\n\u251c\u2500 release.yml\n\u2502  \u251c\u2500 1. Run tests\n\u2502  \u251c\u2500 2. Build Python package\n\u2502  \u251c\u2500 3. Publish to PyPI\n\u2502  \u2514\u2500 4. Create GitHub Release\n\u2502\n\u2514\u2500 build-binaries.yml\n   \u251c\u2500 1. Build macOS app (parallel)\n   \u251c\u2500 2. Build Windows exe (parallel)\n   \u251c\u2500 3. Build Linux AppImage (parallel)\n   \u2514\u2500 4. Upload binaries to release\n</code></pre> <p>Result: GitHub release with: - Auto-generated release notes - macOS: <code>KVM-Serial-v1.5.2-macOS.zip</code> and <code>.dmg</code> - Windows: <code>KVM-Serial-v1.5.2-Windows.zip</code> - Linux: <code>KVM-Serial-v1.5.2-x86_64.AppImage</code></p>"},{"location":"workflows/#manual-testing","title":"Manual Testing","text":"<p>You can manually trigger the binary builds workflow:</p> <ol> <li>Go to Actions \u2192 Build Executable Binaries</li> <li>Click \"Run workflow\"</li> <li>Select branch</li> <li>Click \"Run workflow\"</li> </ol> <p>This will build binaries but won't create a release (useful for testing).</p>"},{"location":"workflows/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"workflows/#macos","title":"macOS","text":"<ul> <li>Uses onedir mode (PyInstaller 7.0 compatible)</li> <li>Creates <code>.app</code> bundle with all dependencies in <code>Contents/Frameworks/</code></li> <li>DMG creation uses <code>create-dmg</code> for professional installer</li> <li>Includes proper Info.plist with privacy permissions</li> </ul>"},{"location":"workflows/#windows","title":"Windows","text":"<ul> <li>Uses onefile mode for simpler distribution</li> <li>Single <code>.exe</code> file with all dependencies embedded</li> <li>Icon embedded in executable</li> <li>No console window (GUI mode)</li> </ul>"},{"location":"workflows/#linux","title":"Linux","text":"<ul> <li>Uses onefile mode with AppImage packaging</li> <li>Single portable <code>.AppImage</code> file that runs on most distros</li> <li>Includes PyQt5 system dependencies (xcb, GL, etc.)</li> <li>No installation required - just download, chmod +x, and run</li> <li>Compatible with Ubuntu, Fedora, Debian, and derivatives</li> </ul>"},{"location":"workflows/#build-requirements","title":"Build Requirements","text":"<p>Each platform runner has: - Python 3.10 - All dependencies from <code>requirements.txt</code> - PyInstaller 6.0+ (from dev dependencies)</p>"},{"location":"workflows/#troubleshooting","title":"Troubleshooting","text":""},{"location":"workflows/#build-fails-on-macos","title":"Build fails on macOS","text":"<ul> <li>Check if icon files exist in <code>assets/</code></li> <li>Verify <code>kvm_serial/kvm.py</code> exists</li> <li>Check hidden imports in <code>kvm-gui.spec</code></li> </ul>"},{"location":"workflows/#build-fails-on-windows","title":"Build fails on Windows","text":"<ul> <li>Verify <code>icon.ico</code> exists</li> <li>Check Windows-specific dependencies</li> <li>Ensure <code>console=False</code> for GUI mode</li> </ul>"},{"location":"workflows/#build-fails-on-linux","title":"Build fails on Linux","text":"<ul> <li>Check PyQt5 system dependencies are installed</li> <li>Verify AppImage tools downloaded successfully</li> <li>Ensure <code>icon.png</code> exists in <code>assets/</code></li> <li>Check AppDir structure creation</li> </ul>"},{"location":"workflows/#binaries-not-attached-to-release","title":"Binaries not attached to release","text":"<ul> <li>Verify <code>contents: write</code> permission</li> <li>Check artifact upload/download steps</li> <li>Ensure tag format matches <code>v*</code></li> </ul>"},{"location":"workflows/#security","title":"Security","text":"<ul> <li>PyPI publishing uses OIDC (no API tokens)</li> <li>Release creation requires <code>contents: write</code> permission</li> <li>Workflows only trigger on tags (protected)</li> </ul>"},{"location":"workflows/#code-signing","title":"Code Signing","text":"<ul> <li>macOS: Builds are ad-hoc signed with entitlements for proper permission handling</li> <li>Entitlements file: <code>assets/entitlements.plist</code></li> <li>Signing command: <code>codesign --force --deep --sign - --entitlements assets/entitlements.plist \"dist/KVM Serial.app\"</code></li> <li>Ad-hoc signatures work for local testing but not for distribution outside GitHub</li> <li>Windows: Not currently signed (users will see SmartScreen warnings)</li> <li>Linux: AppImage format doesn't require code signing</li> </ul> <p>For public distribution, proper certificates are recommended:</p> <ul> <li>macOS: Apple Developer ID certificate ($99/year for notarization)</li> <li>Windows: Code signing certificate (~$100-500/year)</li> </ul>"},{"location":"workflows/#future-improvements","title":"Future Improvements","text":"<ul> <li>[x] Add Linux builds (AppImage) - \u2705 Completed</li> <li>[ ] Code signing for macOS (requires Apple Developer account)</li> <li>[ ] Code signing for Windows (requires certificate)</li> <li>[ ] Automated testing of built executables</li> <li>[ ] Build size optimization</li> </ul>"}]}